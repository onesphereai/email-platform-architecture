<!DOCTYPE html>
<html>
<head>
    <title>Client_Email_Authentication_Validation</title>
    <meta charset="utf-8">
</head>
<body>
<!-- Confluence Storage Format -->
<h1>Client Email Authentication Validation System</h1>
<br/>
<h2>Overview</h2>
<p>This document explains how to validate that client email addresses (e.g., &quot;marketing@client.com.au&quot;) have proper SPF, DKIM, and DMARC authentication setup before allowing them to send emails through our SES platform. This protects our platform&#x27;s reputation and ensures high deliverability.</p>
<br/>
<h2>The Challenge</h2>
<br/>
<h3>Scenario</h3>
<ul>
<li>Client wants to use &quot;marketing@client.com.au&quot; as the From address</li>
<li>Client will send emails to many recipients through our SES platform</li>
<li>We need to validate that client.com.au has proper email authentication</li>
<li>We don&#x27;t control the client&#x27;s DNS - they do</li>
<li>We need to ensure their authentication won&#x27;t cause deliverability issues</li>
</ul>
<br/>
<h3>Why Validation is Critical</h3>
<ol>
<li><strong>Platform Reputation</strong>: Poorly authenticated domains can hurt our SES reputation</li>
<li><strong>Deliverability</strong>: Recipients may reject emails from unauthenticated domains</li>
<li><strong>Compliance</strong>: Many email providers require proper authentication</li>
<li><strong>Client Success</strong>: Ensures client&#x27;s emails reach inboxes</li>
</ol>
<br/>
<h2>Authentication Validation System</h2>
<br/>
<h3>1. DNS-Based Authentication Checks</h3>
<br/>
<h4>SPF Validation</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const validateSPF = async (domain) => {
  try {
    // Get SPF record from DNS
    const spfRecord = await dnsLookup(domain, 'TXT', 'v=spf1');
    
    if (!spfRecord) {
      return {
        valid: false,
        error: 'NO_SPF_RECORD',
        message: 'No SPF record found for domain',
        recommendation: 'Add SPF record to authorize email senders'
      };
    }
    
    // Parse SPF record
    const spfData = parseSPFRecord(spfRecord);
    
    // Check if SES is authorized (if using custom MAIL FROM)
    const sesAuthorized = spfData.includes.some(include => 
      include.includes('amazonses.com') || 
      include.includes('spf.amazonses.com')
    );
    
    // Validate SPF syntax and mechanisms
    const validation = {
      valid: true,
      record: spfRecord,
      mechanisms: spfData.mechanisms,
      includes: spfData.includes,
      qualifier: spfData.qualifier, // ~all, -all, +all, ?all
      ses_authorized: sesAuthorized,
      warnings: []
    };
    
    // Check for common issues
    if (spfData.qualifier === '+all') {
      validation.warnings.push('SPF record allows all senders (+all) - security risk');
    }
    
    if (spfData.includes.length > 8) {
      validation.warnings.push('Too many SPF includes may cause DNS lookup limit issues');
    }
    
    return validation;
    
  } catch (error) {
    return {
      valid: false,
      error: 'DNS_LOOKUP_FAILED',
      message: `Failed to lookup SPF record: ${error.message}`
    };
  }
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h4>DKIM Validation</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const validateDKIM = async (domain) => {
  try {
    // Common DKIM selectors to check
    const commonSelectors = [
      'default', 'selector1', 'selector2', 'google', 'k1', 'k2',
      'dkim', 'mail', 'email', 's1', 's2', 'key1', 'key2'
    ];
    
    const dkimResults = {
      valid: false,
      selectors_found: [],
      selectors_checked: commonSelectors,
      active_keys: [],
      warnings: []
    };
    
    // Check each common selector
    for (const selector of commonSelectors) {
      try {
        const dkimRecord = await dnsLookup(`${selector}._domainkey.${domain}`, 'TXT');
        
        if (dkimRecord && dkimRecord.includes('k=rsa')) {
          dkimResults.selectors_found.push({
            selector: selector,
            record: dkimRecord,
            key_type: extractDKIMKeyType(dkimRecord),
            public_key: extractDKIMPublicKey(dkimRecord)
          });
          
          dkimResults.valid = true;
        }
      } catch (error) {
        // Selector not found - continue checking others
        continue;
      }
    }
    
    // Additional validation for found DKIM keys
    if (dkimResults.selectors_found.length === 0) {
      dkimResults.error = 'NO_DKIM_RECORDS';
      dkimResults.message = 'No DKIM records found with common selectors';
      dkimResults.recommendation = 'Set up DKIM signing for the domain';
    } else {
      // Validate DKIM key strength
      dkimResults.selectors_found.forEach(selector => {
        const keyLength = estimateDKIMKeyLength(selector.public_key);
        if (keyLength < 1024) {
          dkimResults.warnings.push(`Selector ${selector.selector} uses weak key (< 1024 bits)`);
        }
      });
    }
    
    return dkimResults;
    
  } catch (error) {
    return {
      valid: false,
      error: 'DNS_LOOKUP_FAILED',
      message: `Failed to lookup DKIM records: ${error.message}`
    };
  }
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h4>DMARC Validation</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const validateDMARC = async (domain) => {
  try {
    // Get DMARC record
    const dmarcRecord = await dnsLookup(`_dmarc.${domain}`, 'TXT', 'v=DMARC1');
    
    if (!dmarcRecord) {
      return {
        valid: false,
        error: 'NO_DMARC_RECORD',
        message: 'No DMARC record found for domain',
        recommendation: 'Add DMARC record to specify authentication policy'
      };
    }
    
    // Parse DMARC record
    const dmarcData = parseDMARCRecord(dmarcRecord);
    
    const validation = {
      valid: true,
      record: dmarcRecord,
      policy: dmarcData.p, // none, quarantine, reject
      subdomain_policy: dmarcData.sp,
      alignment: {
        dkim: dmarcData.adkim || 'r', // relaxed or strict
        spf: dmarcData.aspf || 'r'
      },
      percentage: dmarcData.pct || 100,
      reporting: {
        aggregate: dmarcData.rua || [],
        forensic: dmarcData.ruf || []
      },
      warnings: [],
      risk_level: 'low'
    };
    
    // Assess risk level based on policy
    if (dmarcData.p === 'reject') {
      validation.risk_level = 'high';
      validation.warnings.push('DMARC policy is set to reject - authentication failures will cause email rejection');
    } else if (dmarcData.p === 'quarantine') {
      validation.risk_level = 'medium';
      validation.warnings.push('DMARC policy is set to quarantine - authentication failures may affect deliverability');
    }
    
    // Check alignment settings
    if (dmarcData.adkim === 's' || dmarcData.aspf === 's') {
      validation.warnings.push('Strict DMARC alignment may cause authentication issues with third-party senders');
    }
    
    return validation;
    
  } catch (error) {
    return {
      valid: false,
      error: 'DNS_LOOKUP_FAILED',
      message: `Failed to lookup DMARC record: ${error.message}`
    };
  }
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>2. Comprehensive Email Address Validation</h3>
<br/>
<h4>Complete Validation Function</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const validateClientEmail = async (emailAddress) => {
  const domain = emailAddress.split('@')[1];
  const localPart = emailAddress.split('@')[0];
  
  // Run all authentication checks in parallel
  const [spfResult, dkimResult, dmarcResult, mxResult] = await Promise.all([
    validateSPF(domain),
    validateDKIM(domain),
    validateDMARC(domain),
    validateMXRecords(domain)
  ]);
  
  // Calculate overall authentication score
  const authScore = calculateAuthenticationScore(spfResult, dkimResult, dmarcResult);
  
  // Determine if email is approved for sending
  const approval = determineApprovalStatus(authScore, spfResult, dkimResult, dmarcResult);
  
  return {
    email_address: emailAddress,
    domain: domain,
    validation_timestamp: new Date().toISOString(),
    authentication: {
      spf: spfResult,
      dkim: dkimResult,
      dmarc: dmarcResult,
      mx: mxResult
    },
    overall_score: authScore,
    approval_status: approval.status, // approved, conditional, rejected
    approval_reason: approval.reason,
    recommendations: generateRecommendations(spfResult, dkimResult, dmarcResult),
    risk_assessment: assessDeliverabilityRisk(spfResult, dkimResult, dmarcResult)
  };
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h4>Authentication Scoring System</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const calculateAuthenticationScore = (spf, dkim, dmarc) => {
  let score = 0;
  let maxScore = 100;
  
  // SPF scoring (30 points)
  if (spf.valid) {
    score += 25;
    if (spf.qualifier === '-all') score += 5; // Strict SPF
  }
  
  // DKIM scoring (40 points)
  if (dkim.valid) {
    score += 30;
    score += Math.min(dkim.selectors_found.length * 5, 10); // Multiple selectors bonus
  }
  
  // DMARC scoring (30 points)
  if (dmarc.valid) {
    score += 20;
    if (dmarc.policy === 'quarantine') score += 5;
    if (dmarc.policy === 'reject') score += 10;
  }
  
  return Math.round((score / maxScore) * 100);
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h4>Approval Decision Logic</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const determineApprovalStatus = (score, spf, dkim, dmarc) => {
  // High score - automatic approval
  if (score >= 80 && spf.valid && dkim.valid && dmarc.valid) {
    return {
      status: 'approved',
      reason: 'Excellent authentication setup',
      conditions: []
    };
  }
  
  // Medium score - conditional approval
  if (score >= 60 && (spf.valid || dkim.valid)) {
    const conditions = [];
    
    if (!spf.valid) conditions.push('Add SPF record');
    if (!dkim.valid) conditions.push('Set up DKIM signing');
    if (!dmarc.valid) conditions.push('Add DMARC policy');
    
    return {
      status: 'conditional',
      reason: 'Partial authentication setup - may affect deliverability',
      conditions: conditions,
      monitoring_required: true
    };
  }
  
  // Low score - rejection
  return {
    status: 'rejected',
    reason: 'Insufficient email authentication setup',
    required_actions: [
      'Set up SPF record to authorize email senders',
      'Configure DKIM signing for the domain',
      'Add DMARC policy for authentication compliance'
    ]
  };
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>3. API Integration</h3>
<br/>
<h4>Email Validation Endpoint</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
POST /api/v1/clients/{clientId}/emails/validate
{
  "email_address": "marketing@client.com.au",
  "intended_volume": 10000, // emails per month
  "campaign_types": ["marketing", "transactional"]
}

// Response
{
  "validation_id": "val-123",
  "email_address": "marketing@client.com.au",
  "domain": "client.com.au",
  "validation_result": {
    "overall_score": 85,
    "approval_status": "approved",
    "authentication": {
      "spf": {
        "valid": true,
        "record": "v=spf1 include:_spf.google.com ~all",
        "ses_authorized": false
      },
      "dkim": {
        "valid": true,
        "selectors_found": ["google", "selector1"],
        "active_keys": 2
      },
      "dmarc": {
        "valid": true,
        "policy": "quarantine",
        "alignment": {"dkim": "r", "spf": "r"}
      }
    },
    "recommendations": [
      "Consider adding include:amazonses.com to SPF record for better authentication",
      "Monitor DMARC reports for authentication issues"
    ],
    "risk_assessment": {
      "deliverability_risk": "low",
      "reputation_risk": "low",
      "compliance_risk": "low"
    }
  }
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h4>Email Approval Workflow</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const processEmailApproval = async (clientId, emailAddress, validationResult) => {
  const approval = {
    client_id: clientId,
    email_address: emailAddress,
    validation_id: validationResult.validation_id,
    status: validationResult.approval_status,
    approved_at: new Date().toISOString(),
    conditions: validationResult.conditions || [],
    monitoring_enabled: validationResult.monitoring_required || false
  };
  
  // Store approval in database
  await storeEmailApproval(approval);
  
  // Set up monitoring if required
  if (approval.monitoring_enabled) {
    await setupAuthenticationMonitoring(emailAddress);
  }
  
  // Notify client of approval status
  await notifyClientOfApproval(clientId, approval);
  
  return approval;
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>4. Ongoing Monitoring</h3>
<br/>
<h4>Authentication Health Monitoring</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const monitorEmailAuthentication = async (emailAddress) => {
  const domain = emailAddress.split('@')[1];
  
  // Re-validate authentication periodically
  const currentValidation = await validateClientEmail(emailAddress);
  const previousValidation = await getPreviousValidation(emailAddress);
  
  // Compare with previous validation
  const changes = detectAuthenticationChanges(previousValidation, currentValidation);
  
  if (changes.length > 0) {
    // Alert client about authentication changes
    await alertClientAboutChanges(emailAddress, changes);
    
    // Re-evaluate approval status
    const newApproval = determineApprovalStatus(
      currentValidation.overall_score,
      currentValidation.authentication.spf,
      currentValidation.authentication.dkim,
      currentValidation.authentication.dmarc
    );
    
    if (newApproval.status !== previousValidation.approval_status) {
      await updateEmailApprovalStatus(emailAddress, newApproval);
    }
  }
  
  return {
    email_address: emailAddress,
    monitoring_timestamp: new Date().toISOString(),
    authentication_status: currentValidation.authentication,
    changes_detected: changes,
    action_required: changes.some(change => change.severity === 'high')
  };
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>5. Client Communication</h3>
<br/>
<h4>Validation Results Dashboard</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
// Client dashboard showing email validation status
const getEmailValidationDashboard = async (clientId) => {
  const clientEmails = await getClientEmails(clientId);
  
  const dashboard = {
    client_id: clientId,
    total_emails: clientEmails.length,
    approved_emails: clientEmails.filter(e => e.status === 'approved').length,
    conditional_emails: clientEmails.filter(e => e.status === 'conditional').length,
    rejected_emails: clientEmails.filter(e => e.status === 'rejected').length,
    emails: clientEmails.map(email => ({
      email_address: email.address,
      status: email.approval_status,
      score: email.authentication_score,
      last_validated: email.last_validation_date,
      issues: email.current_issues || [],
      recommendations: email.recommendations || []
    }))
  };
  
  return dashboard;
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h4>Improvement Recommendations</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
const generateImprovementPlan = (validationResult) => {
  const plan = {
    priority_actions: [],
    optional_improvements: [],
    estimated_impact: {}
  };
  
  // High priority actions
  if (!validationResult.authentication.spf.valid) {
    plan.priority_actions.push({
      action: 'Add SPF record',
      dns_record: `${validationResult.domain} TXT "v=spf1 include:_spf.google.com ~all"`,
      impact: 'Critical for email authentication',
      urgency: 'high'
    });
  }
  
  if (!validationResult.authentication.dkim.valid) {
    plan.priority_actions.push({
      action: 'Set up DKIM signing',
      description: 'Configure DKIM with your email provider',
      impact: 'Significantly improves deliverability',
      urgency: 'high'
    });
  }
  
  if (!validationResult.authentication.dmarc.valid) {
    plan.priority_actions.push({
      action: 'Add DMARC policy',
      dns_record: `_dmarc.${validationResult.domain} TXT "v=DMARC1; p=none; rua=mailto:dmarc@${validationResult.domain}"`,
      impact: 'Required by major email providers',
      urgency: 'medium'
    });
  }
  
  return plan;
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h2>Implementation Best Practices</h2>
<br/>
<h3>1. Validation Frequency</h3>
<ul>
<li><strong>Initial validation</strong>: Before approving email for sending</li>
<li><strong>Periodic re-validation</strong>: Weekly for approved emails</li>
<li><strong>Triggered validation</strong>: When DNS changes detected</li>
<li><strong>Pre-campaign validation</strong>: Before large email campaigns</li>
</ul>
<br/>
<h3>2. Risk Management</h3>
<ul>
<li><strong>Gradual approval</strong>: Start with small sending volumes</li>
<li><strong>Monitoring alerts</strong>: Real-time authentication issue detection</li>
<li><strong>Automatic suspension</strong>: Suspend sending if authentication fails</li>
<li><strong>Client notification</strong>: Immediate alerts for critical issues</li>
</ul>
<br/>
<h3>3. Client Education</h3>
<ul>
<li><strong>Clear documentation</strong>: Explain authentication requirements</li>
<li><strong>Step-by-step guides</strong>: Help clients fix authentication issues</li>
<li><strong>Best practices</strong>: Share email authentication best practices</li>
<li><strong>Ongoing support</strong>: Provide technical assistance</li>
</ul>
<br/>
<p>This validation system ensures that only properly authenticated client email addresses can send through your SES platform, protecting both your reputation and your clients&#x27; deliverability! 🛡️</p>
<br/>
</body>
</html>