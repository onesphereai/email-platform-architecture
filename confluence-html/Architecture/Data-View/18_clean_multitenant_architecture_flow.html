<!DOCTYPE html>
<html>
<head>
    <title>18_clean_multitenant_architecture_flow</title>
    <meta charset="utf-8">
</head>
<body>
<!-- Confluence Storage Format -->
<h1>Multi-Tenant Data Architecture - Flow Description</h1>
<br/>
<p><strong>Diagram</strong>: <code>18<em>clean</em>multitenant_architecture.png</code></p>
<br/>
<h2>Overview</h2>
<p>This diagram illustrates the multi-tenant silo model implementation, showing how data is completely isolated between tenants while maintaining operational efficiency through shared infrastructure.</p>
<br/>
<h2>Component Flow Analysis</h2>
<br/>
<table>
<thead>
<tr>
<th>Component</th>
<th>Type</th>
<th>Purpose</th>
<th>Tenant Isolation Method</th>
<th>Data Flow</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tenant A</td>
<td>External User</td>
<td>First tenant organization</td>
<td>Unique tenant ID</td>
<td>→ API Gateway</td>
</tr>
<tr>
<td>Tenant B</td>
<td>External User</td>
<td>Second tenant organization</td>
<td>Unique tenant ID</td>
<td>→ API Gateway</td>
</tr>
<tr>
<td>Tenant C</td>
<td>External User</td>
<td>Third tenant organization</td>
<td>Unique tenant ID</td>
<td>→ API Gateway</td>
</tr>
<tr>
<td>API Gateway</td>
<td>API Layer</td>
<td>Request routing and validation</td>
<td>Tenant context extraction</td>
<td>→ Tenant Resolver</td>
</tr>
<tr>
<td>Tenant Resolver</td>
<td>Service Layer</td>
<td>Tenant identification and context</td>
<td>Tenant ID validation</td>
<td>→ Data Services</td>
</tr>
<tr>
<td>EmailPlatform Table</td>
<td>Database</td>
<td>Single DynamoDB table</td>
<td>Partition key prefixing</td>
<td>← Tenant Resolver</td>
</tr>
<tr>
<td>Partition Keys</td>
<td>Data Pattern</td>
<td>Data organization strategy</td>
<td>TENANT#{id}#{entity}#{id}</td>
<td>Within DynamoDB</td>
</tr>
<tr>
<td>S3 Bucket</td>
<td>File Storage</td>
<td>Shared storage bucket</td>
<td>Folder-based isolation</td>
<td>← Tenant Resolver</td>
</tr>
<tr>
<td>Tenant Folders</td>
<td>Storage Pattern</td>
<td>Folder organization</td>
<td>tenant-{id}/ prefix</td>
<td>Within S3 Bucket</td>
</tr>
<tr>
<td>OpenSearch</td>
<td>Analytics</td>
<td>Shared search cluster</td>
<td>Index-based isolation</td>
<td>← Tenant Resolver</td>
</tr>
<tr>
<td>Tenant Indexes</td>
<td>Index Pattern</td>
<td>Search index organization</td>
<td>email-tenant-{id}</td>
<td>Within OpenSearch</td>
</tr>
</tbody>
</table>
<br/>
<h2>Multi-Tenancy Implementation</h2>
<br/>
<h3>Tenant Identification Flow</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">none</ac:parameter>
  <ac:plain-text-body><![CDATA[
User Request → API Gateway → Extract Tenant Context → Validate Tenant → Route to Services
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>Data Access Pattern</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">none</ac:parameter>
  <ac:plain-text-body><![CDATA[
Service Request → Tenant Context → Partition Key Generation → Data Access → Tenant-Filtered Results
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>Storage Isolation Pattern</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">none</ac:parameter>
  <ac:plain-text-body><![CDATA[
File Operation → Tenant Context → Path Generation → Tenant-Specific Storage → Isolated Access
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h2>Data Isolation Strategies</h2>
<br/>
<h3>DynamoDB Single Table Design</h3>
<br/>
<h4>Partition Key Patterns</h4>
<table>
<thead>
<tr>
<th>Entity Type</th>
<th>Partition Key Format</th>
<th>Sort Key Format</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tenant Config</td>
<td>`TENANT#{tenantId}`</td>
<td>`CONFIG`</td>
<td>`TENANT#A#CONFIG`</td>
</tr>
<tr>
<td>User Profile</td>
<td>`TENANT#{tenantId}`</td>
<td>`USER#{userId}`</td>
<td>`TENANT#A#USER#123`</td>
</tr>
<tr>
<td>Campaign</td>
<td>`TENANT#{tenantId}`</td>
<td>`CAMPAIGN#{campaignId}`</td>
<td>`TENANT#A#CAMPAIGN#456`</td>
</tr>
<tr>
<td>Template</td>
<td>`TENANT#{tenantId}`</td>
<td>`TEMPLATE#{templateId}`</td>
<td>`TENANT#A#TEMPLATE#789`</td>
</tr>
<tr>
<td>Recipient List</td>
<td>`TENANT#{tenantId}`</td>
<td>`LIST#{listId}`</td>
<td>`TENANT#A#LIST#101`</td>
</tr>
<tr>
<td>Analytics</td>
<td>`TENANT#{tenantId}`</td>
<td>`ANALYTICS#{date}#{metric}`</td>
<td>`TENANT#A#ANALYTICS#2024-01-15#OPENS`</td>
</tr>
</tbody>
</table>
<br/>
<h4>Access Pattern Examples</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
// Get all campaigns for Tenant A
const params = {
  TableName: 'EmailPlatform',
  KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
  ExpressionAttributeValues: {
    ':pk': 'TENANT#A',
    ':sk': 'CAMPAIGN#'
  }
};

// Get specific user for Tenant B
const params = {
  TableName: 'EmailPlatform',
  Key: {
    'PK': 'TENANT#B',
    'SK': 'USER#123'
  }
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>S3 Folder-Based Isolation</h3>
<br/>
<h4>Folder Structure</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">none</ac:parameter>
  <ac:plain-text-body><![CDATA[
s3://email-platform-storage/
├── tenant-a/
│   ├── templates/
│   │   ├── html/
│   │   ├── images/
│   │   └── css/
│   ├── exports/
│   └── backups/
├── tenant-b/
│   ├── templates/
│   ├── exports/
│   └── backups/
└── tenant-c/
    ├── templates/
    ├── exports/
    └── backups/
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h4>Access Control Policy</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">json</ac:parameter>
  <ac:plain-text-body><![CDATA[
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::account:role/EmailPlatformRole"
      },
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ],
      "Resource": "arn:aws:s3:::email-platform-storage/tenant-${aws:userid}/*"
    }
  ]
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>OpenSearch Index Isolation</h3>
<br/>
<h4>Index Naming Convention</h4>
<table>
<thead>
<tr>
<th>Tenant</th>
<th>Index Name</th>
<th>Purpose</th>
<th>Data Types</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tenant A</td>
<td>`email-analytics-tenant-a`</td>
<td>Email analytics</td>
<td>Opens, clicks, bounces</td>
</tr>
<tr>
<td>Tenant B</td>
<td>`email-analytics-tenant-b`</td>
<td>Email analytics</td>
<td>Opens, clicks, bounces</td>
</tr>
<tr>
<td>Tenant C</td>
<td>`email-analytics-tenant-c`</td>
<td>Email analytics</td>
<td>Opens, clicks, bounces</td>
</tr>
</tbody>
</table>
<br/>
<h4>Index Template</h4>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">json</ac:parameter>
  <ac:plain-text-body><![CDATA[
{
  "index_patterns": ["email-analytics-tenant-*"],
  "template": {
    "settings": {
      "number_of_shards": 1,
      "number_of_replicas": 1
    },
    "mappings": {
      "properties": {
        "tenantId": { "type": "keyword" },
        "campaignId": { "type": "keyword" },
        "eventType": { "type": "keyword" },
        "timestamp": { "type": "date" },
        "recipient": { "type": "keyword" },
        "metadata": { "type": "object" }
      }
    }
  }
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h2>Tenant Context Management</h2>
<br/>
<h3>Tenant Resolution Process</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
class TenantResolver {
  async resolveTenant(request) {
    // Extract tenant from JWT token
    const token = this.extractJWTToken(request);
    const claims = this.validateToken(token);
    const tenantId = claims['custom:tenantId'];
    
    // Validate tenant exists and is active
    const tenant = await this.validateTenant(tenantId);
    
    return {
      tenantId: tenantId,
      tenantName: tenant.name,
      permissions: claims['custom:permissions'],
      partitionPrefix: `TENANT#${tenantId}`,
      s3Prefix: `tenant-${tenantId}`,
      searchIndex: `email-analytics-tenant-${tenantId}`
    };
  }
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>Data Access Layer</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
class TenantAwareDataAccess {
  constructor(tenantContext) {
    this.tenantContext = tenantContext;
  }
  
  async getCampaigns() {
    const params = {
      TableName: 'EmailPlatform',
      KeyConditionExpression: 'PK = :pk AND begins_with(SK, :sk)',
      ExpressionAttributeValues: {
        ':pk': this.tenantContext.partitionPrefix,
        ':sk': 'CAMPAIGN#'
      }
    };
    
    return await this.dynamodb.query(params).promise();
  }
  
  async storeTemplate(templateData) {
    const s3Key = `${this.tenantContext.s3Prefix}/templates/${templateData.id}.html`;
    
    return await this.s3.putObject({
      Bucket: 'email-platform-storage',
      Key: s3Key,
      Body: templateData.content
    }).promise();
  }
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h2>Security and Compliance</h2>
<br/>
<h3>Data Isolation Guarantees</h3>
<ul>
<li><strong>Physical Separation</strong>: No shared data structures between tenants</li>
<li><strong>Logical Separation</strong>: Partition keys prevent cross-tenant access</li>
<li><strong>Access Control</strong>: IAM policies enforce tenant boundaries</li>
<li><strong>Audit Trail</strong>: All access logged with tenant context</li>
</ul>
<br/>
<h3>Compliance Features</h3>
<ul>
<li><strong>GDPR Compliance</strong>: Tenant-specific data deletion</li>
<li><strong>Data Residency</strong>: Geographic data placement per tenant</li>
<li><strong>Audit Logging</strong>: Comprehensive access logging</li>
<li><strong>Encryption</strong>: Tenant-specific encryption keys (optional)</li>
</ul>
<br/>
<h3>Security Measures</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
// Tenant boundary validation
function validateTenantAccess(requestTenant, resourceTenant) {
  if (requestTenant !== resourceTenant) {
    throw new Error('Cross-tenant access denied');
  }
}

// Automatic tenant context injection
function injectTenantContext(query, tenantId) {
  if (!query.KeyConditionExpression.includes('TENANT#')) {
    throw new Error('Query must include tenant context');
  }
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h2>Performance Considerations</h2>
<br/>
<h3>DynamoDB Optimization</h3>
<ul>
<li><strong>Hot Partition Avoidance</strong>: Distributed partition keys</li>
<li><strong>GSI Design</strong>: Tenant-aware global secondary indexes</li>
<li><strong>Batch Operations</strong>: Tenant-scoped batch operations</li>
<li><strong>Connection Pooling</strong>: Shared connections across tenants</li>
</ul>
<br/>
<h3>S3 Optimization</h3>
<ul>
<li><strong>Prefix Distribution</strong>: Avoid hot-spotting with random prefixes</li>
<li><strong>Multipart Upload</strong>: Efficient large file uploads</li>
<li><strong>Lifecycle Policies</strong>: Tenant-specific data lifecycle</li>
<li><strong>Transfer Acceleration</strong>: Global upload optimization</li>
</ul>
<br/>
<h3>OpenSearch Optimization</h3>
<ul>
<li><strong>Index Sharding</strong>: Appropriate shard count per tenant</li>
<li><strong>Replica Strategy</strong>: Balanced replica distribution</li>
<li><strong>Query Optimization</strong>: Tenant-scoped queries</li>
<li><strong>Aggregation Caching</strong>: Tenant-specific caching</li>
</ul>
<br/>
<h2>Operational Management</h2>
<br/>
<h3>Tenant Onboarding</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
async function onboardTenant(tenantData) {
  // Create tenant record
  await createTenantRecord(tenantData);
  
  // Initialize S3 folder structure
  await initializeTenantStorage(tenantData.id);
  
  // Create OpenSearch index
  await createTenantIndex(tenantData.id);
  
  // Set up monitoring
  await setupTenantMonitoring(tenantData.id);
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>Tenant Offboarding</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
async function offboardTenant(tenantId) {
  // Delete all tenant data
  await deleteTenantData(tenantId);
  
  // Remove S3 objects
  await deleteTenantStorage(tenantId);
  
  // Delete OpenSearch index
  await deleteTenantIndex(tenantId);
  
  // Clean up monitoring
  await cleanupTenantMonitoring(tenantId);
}
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>Monitoring and Metrics</h3>
<ul>
<li><strong>Per-Tenant Metrics</strong>: Usage, performance, errors</li>
<li><strong>Cross-Tenant Analytics</strong>: Platform-wide insights</li>
<li><strong>Cost Allocation</strong>: Tenant-specific cost tracking</li>
<li><strong>Capacity Planning</strong>: Per-tenant growth projections</li>
</ul>
<br/>
<h2>Scalability Patterns</h2>
<br/>
<h3>Horizontal Scaling</h3>
<ul>
<li><strong>Tenant Sharding</strong>: Distribute tenants across regions</li>
<li><strong>Index Scaling</strong>: Scale OpenSearch clusters per tenant tier</li>
<li><strong>Storage Scaling</strong>: Automatic S3 scaling</li>
<li><strong>Compute Scaling</strong>: Lambda auto-scaling per tenant load</li>
</ul>
<br/>
<h3>Vertical Scaling</h3>
<ul>
<li><strong>Resource Allocation</strong>: Tenant-specific resource limits</li>
<li><strong>Performance Tiers</strong>: Different service levels per tenant</li>
<li><strong>Capacity Reservations</strong>: Guaranteed capacity for premium tenants</li>
<li><strong>Priority Queuing</strong>: Tenant-based processing priorities</li>
</ul>
<br/>
<h2>Cost Optimization</h2>
<br/>
<h3>Resource Sharing</h3>
<ul>
<li><strong>Infrastructure Sharing</strong>: Shared AWS services</li>
<li><strong>Operational Efficiency</strong>: Single operational model</li>
<li><strong>Bulk Purchasing</strong>: Shared reserved capacity</li>
<li><strong>Automation</strong>: Shared automation and tooling</li>
</ul>
<br/>
<h3>Cost Allocation</h3>
<ac:structured-macro ac:name="code" ac:schema-version="1">
  <ac:parameter ac:name="language">javascript</ac:parameter>
  <ac:plain-text-body><![CDATA[
// Cost allocation by tenant
const costAllocation = {
  tenantA: {
    dynamodbCost: calculateDynamoDBCost('TENANT#A'),
    s3Cost: calculateS3Cost('tenant-a/'),
    lambdaCost: calculateLambdaCost('tenant-a'),
    sesCost: calculateSESCost('tenant-a')
  }
};
]]></ac:plain-text-body>
</ac:structured-macro>
<br/>
<h3>Usage-Based Pricing</h3>
<ul>
<li><strong>Metered Billing</strong>: Pay-per-use model</li>
<li><strong>Tier-Based Pricing</strong>: Different pricing tiers</li>
<li><strong>Resource Limits</strong>: Tenant-specific quotas</li>
<li><strong>Overage Charges</strong>: Usage beyond limits</li>
</ul>
<br/>
</body>
</html>